c21dea9111bf9a713f10c38a881abe8a
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
require("expect-even-more-jest");
var filesystem_sandbox_1 = require("filesystem-sandbox");
var faker = __importStar(require("faker"));
var git_broadcast_1 = require("../src/git-broadcast");
var repository_1 = require("./repository");
describe("git-broadcast", function () {
    beforeEach(function () {
        // we're doing fs-ops here, give things a little more
        // time (though they generally won't need it)
        jest.setTimeout(60000);
    });
    it("should broadcast to a single receiver from the default source", function () { return __awaiter(void 0, void 0, void 0, function () {
        var sandbox, featureBranch, readmeContents, updatedContents, initialMessage, updatedMessage, originPath, localPath, origin, local, currentContents, log;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, filesystem_sandbox_1.Sandbox.create()];
                case 1:
                    sandbox = _a.sent(), featureBranch = "feature/stuff", readmeContents = "initial: " + faker.random.words(), updatedContents = "updated: " + faker.random.words(), initialMessage = ":tada: initial commit", updatedMessage = ":memo: prior docs are all wrong!";
                    return [4 /*yield*/, sandbox.mkdir("origin")];
                case 2:
                    originPath = _a.sent();
                    return [4 /*yield*/, sandbox.mkdir("local")];
                case 3:
                    localPath = _a.sent(), origin = repository_1.Repository.create(originPath);
                    return [4 /*yield*/, origin.init()];
                case 4:
                    _a.sent();
                    return [4 /*yield*/, sandbox.writeFile("origin/readme.md", readmeContents)];
                case 5:
                    _a.sent();
                    return [4 /*yield*/, origin.commitAll(initialMessage)];
                case 6:
                    _a.sent();
                    return [4 /*yield*/, sandbox.writeFile("origin/readme.md", updatedContents)];
                case 7:
                    _a.sent();
                    return [4 /*yield*/, origin.commitAll(updatedMessage)];
                case 8:
                    _a.sent();
                    return [4 /*yield*/, origin.checkout("master")];
                case 9:
                    _a.sent();
                    return [4 /*yield*/, repository_1.Repository.clone(originPath, localPath)];
                case 10:
                    local = _a.sent();
                    return [4 /*yield*/, local.fetch()];
                case 11:
                    _a.sent();
                    return [4 /*yield*/, local.resetHard("HEAD~1")];
                case 12:
                    _a.sent();
                    return [4 /*yield*/, local.checkout("-b", featureBranch)];
                case 13:
                    _a.sent();
                    return [4 /*yield*/, sandbox.readTextFile("local/readme.md")];
                case 14:
                    currentContents = _a.sent();
                    expect(currentContents)
                        .toEqual(readmeContents); // should have readme reset
                    // Act
                    return [4 /*yield*/, git_broadcast_1.gitBroadcast({
                            in: localPath,
                            to: [featureBranch]
                        })
                        // Assert
                    ];
                case 15:
                    // Act
                    _a.sent();
                    // Assert
                    return [4 /*yield*/, local.checkout(featureBranch)];
                case 16:
                    // Assert
                    _a.sent();
                    return [4 /*yield*/, local.log()];
                case 17:
                    log = _a.sent();
                    expect(log.latest.message)
                        .toEqual(updatedMessage);
                    return [2 /*return*/];
            }
        });
    }); });
    it("should broadcast to a globbed single receiver from the default source", function () { return __awaiter(void 0, void 0, void 0, function () {
        var sandbox, featureBranch, readmeContents, updatedContents, initialMessage, updatedMessage, originPath, localPath, origin, local, currentContents, log;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, filesystem_sandbox_1.Sandbox.create()];
                case 1:
                    sandbox = _a.sent(), featureBranch = "feature/stuff", readmeContents = "initial: " + faker.random.words(), updatedContents = "updated: " + faker.random.words(), initialMessage = ":tada: initial commit", updatedMessage = ":memo: prior docs are all wrong!";
                    return [4 /*yield*/, sandbox.mkdir("origin")];
                case 2:
                    originPath = _a.sent();
                    return [4 /*yield*/, sandbox.mkdir("local")];
                case 3:
                    localPath = _a.sent(), origin = repository_1.Repository.create(originPath);
                    return [4 /*yield*/, origin.init()];
                case 4:
                    _a.sent();
                    return [4 /*yield*/, sandbox.writeFile("origin/readme.md", readmeContents)];
                case 5:
                    _a.sent();
                    return [4 /*yield*/, origin.commitAll(initialMessage)];
                case 6:
                    _a.sent();
                    return [4 /*yield*/, sandbox.writeFile("origin/readme.md", updatedContents)];
                case 7:
                    _a.sent();
                    return [4 /*yield*/, origin.commitAll(updatedMessage)];
                case 8:
                    _a.sent();
                    return [4 /*yield*/, origin.checkout("master")];
                case 9:
                    _a.sent();
                    return [4 /*yield*/, repository_1.Repository.clone(originPath, localPath)];
                case 10:
                    local = _a.sent();
                    return [4 /*yield*/, local.fetch()];
                case 11:
                    _a.sent();
                    return [4 /*yield*/, local.resetHard("HEAD~1")];
                case 12:
                    _a.sent();
                    return [4 /*yield*/, local.checkout("-b", featureBranch)];
                case 13:
                    _a.sent();
                    return [4 /*yield*/, sandbox.readTextFile("local/readme.md")];
                case 14:
                    currentContents = _a.sent();
                    expect(currentContents)
                        .toEqual(readmeContents); // should have readme reset
                    // Act
                    return [4 /*yield*/, git_broadcast_1.gitBroadcast({
                            in: localPath,
                            to: ["feature/*"]
                        })
                        // Assert
                    ];
                case 15:
                    // Act
                    _a.sent();
                    // Assert
                    return [4 /*yield*/, local.checkout(featureBranch)];
                case 16:
                    // Assert
                    _a.sent();
                    return [4 /*yield*/, local.log()];
                case 17:
                    log = _a.sent();
                    expect(log.latest.message)
                        .toEqual(updatedMessage);
                    return [2 /*return*/];
            }
        });
    }); });
    it("should broadcast to a globbed single receiver from the specified source", function () { return __awaiter(void 0, void 0, void 0, function () {
        var sandbox, featureBranch, readmeContents, updatedContents, initialMessage, updatedMessage, originPath, localPath, origin, local, currentContents, log;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, filesystem_sandbox_1.Sandbox.create()];
                case 1:
                    sandbox = _a.sent(), featureBranch = "feature/stuff", readmeContents = "initial: " + faker.random.words(), updatedContents = "updated: " + faker.random.words(), initialMessage = ":tada: initial commit", updatedMessage = ":memo: prior docs are all wrong!";
                    return [4 /*yield*/, sandbox.mkdir("origin")];
                case 2:
                    originPath = _a.sent();
                    return [4 /*yield*/, sandbox.mkdir("local")];
                case 3:
                    localPath = _a.sent(), origin = repository_1.Repository.create(originPath);
                    return [4 /*yield*/, origin.init()];
                case 4:
                    _a.sent();
                    return [4 /*yield*/, sandbox.writeFile("origin/readme.md", readmeContents)];
                case 5:
                    _a.sent();
                    return [4 /*yield*/, origin.commitAll(initialMessage)];
                case 6:
                    _a.sent();
                    return [4 /*yield*/, sandbox.writeFile("origin/readme.md", updatedContents)];
                case 7:
                    _a.sent();
                    return [4 /*yield*/, origin.commitAll(updatedMessage)];
                case 8:
                    _a.sent();
                    return [4 /*yield*/, origin.checkout("master")];
                case 9:
                    _a.sent();
                    return [4 /*yield*/, repository_1.Repository.clone(originPath, localPath)];
                case 10:
                    local = _a.sent();
                    return [4 /*yield*/, local.fetch()];
                case 11:
                    _a.sent();
                    return [4 /*yield*/, local.resetHard("HEAD~1")];
                case 12:
                    _a.sent();
                    return [4 /*yield*/, local.checkout("-b", featureBranch)];
                case 13:
                    _a.sent();
                    return [4 /*yield*/, sandbox.readTextFile("local/readme.md")];
                case 14:
                    currentContents = _a.sent();
                    expect(currentContents)
                        .toEqual(readmeContents); // should have readme reset
                    // Act
                    return [4 /*yield*/, git_broadcast_1.gitBroadcast({
                            in: localPath,
                            from: "master",
                            to: ["feature/*"]
                        })
                        // Assert
                    ];
                case 15:
                    // Act
                    _a.sent();
                    // Assert
                    return [4 /*yield*/, local.checkout(featureBranch)];
                case 16:
                    // Assert
                    _a.sent();
                    return [4 /*yield*/, local.log()];
                case 17:
                    log = _a.sent();
                    expect(log.latest.message)
                        .toEqual(updatedMessage);
                    return [2 /*return*/];
            }
        });
    }); });
    afterEach(function () { return __awaiter(void 0, void 0, void 0, function () { return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, filesystem_sandbox_1.Sandbox.destroyAll()];
            case 1: return [2 /*return*/, _a.sent()];
        }
    }); }); });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQzpcXGNvZGVcXG9wZW5zb3VyY2VcXGdpdC1icm9hZGNhc3RcXHRlc3RzXFxnaXQtYnJvYWRjYXN0LnNwZWMudHMiLCJzb3VyY2VzIjpbIkM6XFxjb2RlXFxvcGVuc291cmNlXFxnaXQtYnJvYWRjYXN0XFx0ZXN0c1xcZ2l0LWJyb2FkY2FzdC5zcGVjLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLGlDQUErQjtBQUMvQix5REFBNkM7QUFDN0MsMkNBQStCO0FBQy9CLHNEQUFvRDtBQUNwRCwyQ0FBMEM7QUFFMUMsUUFBUSxDQUFDLGVBQWUsRUFBRTtJQUN0QixVQUFVLENBQUM7UUFDUCxxREFBcUQ7UUFDckQsNkNBQTZDO1FBQzdDLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDM0IsQ0FBQyxDQUFDLENBQUM7SUFDSCxFQUFFLENBQUMsK0RBQStELEVBQUU7Ozs7d0JBR2xELHFCQUFNLDRCQUFPLENBQUMsTUFBTSxFQUFFLEVBQUE7O29CQUFoQyxPQUFPLEdBQUcsU0FBc0IsRUFDaEMsYUFBYSxHQUFHLGVBQWUsRUFDL0IsY0FBYyxHQUFHLGNBQVksS0FBSyxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUksRUFDbkQsZUFBZSxHQUFHLGNBQVksS0FBSyxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUksRUFDcEQsY0FBYyxHQUFHLHVCQUF1QixFQUN4QyxjQUFjLEdBQUcsa0NBQWtDO29CQUN0QyxxQkFBTSxPQUFPLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxFQUFBOztvQkFBMUMsVUFBVSxHQUFHLFNBQTZCO29CQUM5QixxQkFBTSxPQUFPLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxFQUFBOztvQkFBeEMsU0FBUyxHQUFHLFNBQTRCLEVBQ3hDLE1BQU0sR0FBRyx1QkFBVSxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUM7b0JBQzFD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RUFBRSxFQUFBOztvQkFBdkIsR0FBRyxHQUFHLFNBQWlCO29CQUM3QixNQUFNLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUM7eUJBQ3JCLE9BQU8sQ0FBQyxjQUFjLENBQUMsQ0FBQzs7OztTQUNoQyxDQUFDLENBQUM7SUFFSCxTQUFTLENBQUM7O29CQUFZLHFCQUFNLDRCQUFPLENBQUMsVUFBVSxFQUFFLEVBQUE7b0JBQTFCLHNCQUFBLFNBQTBCLEVBQUE7O2FBQUEsQ0FBQyxDQUFDO0FBQ3RELENBQUMsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFwiZXhwZWN0LWV2ZW4tbW9yZS1qZXN0XCI7XHJcbmltcG9ydCB7IFNhbmRib3ggfSBmcm9tIFwiZmlsZXN5c3RlbS1zYW5kYm94XCI7XHJcbmltcG9ydCAqIGFzIGZha2VyIGZyb20gXCJmYWtlclwiO1xyXG5pbXBvcnQgeyBnaXRCcm9hZGNhc3QgfSBmcm9tIFwiLi4vc3JjL2dpdC1icm9hZGNhc3RcIjtcclxuaW1wb3J0IHsgUmVwb3NpdG9yeSB9IGZyb20gXCIuL3JlcG9zaXRvcnlcIjtcclxuXHJcbmRlc2NyaWJlKGBnaXQtYnJvYWRjYXN0YCwgKCkgPT4ge1xyXG4gICAgYmVmb3JlRWFjaCgoKSA9PiB7XHJcbiAgICAgICAgLy8gd2UncmUgZG9pbmcgZnMtb3BzIGhlcmUsIGdpdmUgdGhpbmdzIGEgbGl0dGxlIG1vcmVcclxuICAgICAgICAvLyB0aW1lICh0aG91Z2ggdGhleSBnZW5lcmFsbHkgd29uJ3QgbmVlZCBpdClcclxuICAgICAgICBqZXN0LnNldFRpbWVvdXQoNjAwMDApO1xyXG4gICAgfSk7XHJcbiAgICBpdChgc2hvdWxkIGJyb2FkY2FzdCB0byBhIHNpbmdsZSByZWNlaXZlciBmcm9tIHRoZSBkZWZhdWx0IHNvdXJjZWAsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAvLyBBcnJhbmdlXHJcbiAgICAgICAgY29uc3RcclxuICAgICAgICAgICAgc2FuZGJveCA9IGF3YWl0IFNhbmRib3guY3JlYXRlKCksXHJcbiAgICAgICAgICAgIGZlYXR1cmVCcmFuY2ggPSBcImZlYXR1cmUvc3R1ZmZcIixcclxuICAgICAgICAgICAgcmVhZG1lQ29udGVudHMgPSBgaW5pdGlhbDogJHtmYWtlci5yYW5kb20ud29yZHMoKX1gLFxyXG4gICAgICAgICAgICB1cGRhdGVkQ29udGVudHMgPSBgdXBkYXRlZDogJHtmYWtlci5yYW5kb20ud29yZHMoKX1gLFxyXG4gICAgICAgICAgICBpbml0aWFsTWVzc2FnZSA9IFwiOnRhZGE6IGluaXRpYWwgY29tbWl0XCIsXHJcbiAgICAgICAgICAgIHVwZGF0ZWRNZXNzYWdlID0gXCI6bWVtbzogcHJpb3IgZG9jcyBhcmUgYWxsIHdyb25nIVwiLFxyXG4gICAgICAgICAgICBvcmlnaW5QYXRoID0gYXdhaXQgc2FuZGJveC5ta2RpcihcIm9yaWdpblwiKSxcclxuICAgICAgICAgICAgbG9jYWxQYXRoID0gYXdhaXQgc2FuZGJveC5ta2RpcihcImxvY2FsXCIpLFxyXG4gICAgICAgICAgICBvcmlnaW4gPSBSZXBvc2l0b3J5LmNyZWF0ZShvcmlnaW5QYXRoKTtcclxuICAgICAgICBhd2FpdCBvcmlnaW4uaW5pdCgpO1xyXG4gICAgICAgIGF3YWl0IHNhbmRib3gud3JpdGVGaWxlKFwib3JpZ2luL3JlYWRtZS5tZFwiLCByZWFkbWVDb250ZW50cyk7XHJcbiAgICAgICAgYXdhaXQgb3JpZ2luLmNvbW1pdEFsbChpbml0aWFsTWVzc2FnZSk7XHJcbiAgICAgICAgYXdhaXQgc2FuZGJveC53cml0ZUZpbGUoXCJvcmlnaW4vcmVhZG1lLm1kXCIsIHVwZGF0ZWRDb250ZW50cyk7XHJcbiAgICAgICAgYXdhaXQgb3JpZ2luLmNvbW1pdEFsbCh1cGRhdGVkTWVzc2FnZSk7XHJcbiAgICAgICAgYXdhaXQgb3JpZ2luLmNoZWNrb3V0KFwibWFzdGVyXCIpO1xyXG5cclxuICAgICAgICBjb25zdCBsb2NhbCA9IGF3YWl0IFJlcG9zaXRvcnkuY2xvbmUob3JpZ2luUGF0aCwgbG9jYWxQYXRoKTtcclxuICAgICAgICBhd2FpdCBsb2NhbC5mZXRjaCgpO1xyXG4gICAgICAgIGF3YWl0IGxvY2FsLnJlc2V0SGFyZChcIkhFQUR+MVwiKTtcclxuICAgICAgICBhd2FpdCBsb2NhbC5jaGVja291dChcIi1iXCIsIGZlYXR1cmVCcmFuY2gpO1xyXG5cclxuICAgICAgICBjb25zdCBjdXJyZW50Q29udGVudHMgPSBhd2FpdCBzYW5kYm94LnJlYWRUZXh0RmlsZShcImxvY2FsL3JlYWRtZS5tZFwiKTtcclxuICAgICAgICBleHBlY3QoY3VycmVudENvbnRlbnRzKVxyXG4gICAgICAgICAgICAudG9FcXVhbChyZWFkbWVDb250ZW50cyk7IC8vIHNob3VsZCBoYXZlIHJlYWRtZSByZXNldFxyXG4gICAgICAgIC8vIEFjdFxyXG4gICAgICAgIGF3YWl0IGdpdEJyb2FkY2FzdCh7XHJcbiAgICAgICAgICAgIGluOiBsb2NhbFBhdGgsXHJcbiAgICAgICAgICAgIHRvOiBbIGZlYXR1cmVCcmFuY2ggXVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLy8gQXNzZXJ0XHJcbiAgICAgICAgYXdhaXQgbG9jYWwuY2hlY2tvdXQoZmVhdHVyZUJyYW5jaCk7XHJcbiAgICAgICAgY29uc3QgbG9nID0gYXdhaXQgbG9jYWwubG9nKCk7XHJcbiAgICAgICAgZXhwZWN0KGxvZy5sYXRlc3QubWVzc2FnZSlcclxuICAgICAgICAgICAgLnRvRXF1YWwodXBkYXRlZE1lc3NhZ2UpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoYHNob3VsZCBicm9hZGNhc3QgdG8gYSBnbG9iYmVkIHNpbmdsZSByZWNlaXZlciBmcm9tIHRoZSBkZWZhdWx0IHNvdXJjZWAsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAvLyBBcnJhbmdlXHJcbiAgICAgICAgY29uc3RcclxuICAgICAgICAgICAgc2FuZGJveCA9IGF3YWl0IFNhbmRib3guY3JlYXRlKCksXHJcbiAgICAgICAgICAgIGZlYXR1cmVCcmFuY2ggPSBcImZlYXR1cmUvc3R1ZmZcIixcclxuICAgICAgICAgICAgcmVhZG1lQ29udGVudHMgPSBgaW5pdGlhbDogJHtmYWtlci5yYW5kb20ud29yZHMoKX1gLFxyXG4gICAgICAgICAgICB1cGRhdGVkQ29udGVudHMgPSBgdXBkYXRlZDogJHtmYWtlci5yYW5kb20ud29yZHMoKX1gLFxyXG4gICAgICAgICAgICBpbml0aWFsTWVzc2FnZSA9IFwiOnRhZGE6IGluaXRpYWwgY29tbWl0XCIsXHJcbiAgICAgICAgICAgIHVwZGF0ZWRNZXNzYWdlID0gXCI6bWVtbzogcHJpb3IgZG9jcyBhcmUgYWxsIHdyb25nIVwiLFxyXG4gICAgICAgICAgICBvcmlnaW5QYXRoID0gYXdhaXQgc2FuZGJveC5ta2RpcihcIm9yaWdpblwiKSxcclxuICAgICAgICAgICAgbG9jYWxQYXRoID0gYXdhaXQgc2FuZGJveC5ta2RpcihcImxvY2FsXCIpLFxyXG4gICAgICAgICAgICBvcmlnaW4gPSBSZXBvc2l0b3J5LmNyZWF0ZShvcmlnaW5QYXRoKTtcclxuICAgICAgICBhd2FpdCBvcmlnaW4uaW5pdCgpO1xyXG4gICAgICAgIGF3YWl0IHNhbmRib3gud3JpdGVGaWxlKFwib3JpZ2luL3JlYWRtZS5tZFwiLCByZWFkbWVDb250ZW50cyk7XHJcbiAgICAgICAgYXdhaXQgb3JpZ2luLmNvbW1pdEFsbChpbml0aWFsTWVzc2FnZSk7XHJcbiAgICAgICAgYXdhaXQgc2FuZGJveC53cml0ZUZpbGUoXCJvcmlnaW4vcmVhZG1lLm1kXCIsIHVwZGF0ZWRDb250ZW50cyk7XHJcbiAgICAgICAgYXdhaXQgb3JpZ2luLmNvbW1pdEFsbCh1cGRhdGVkTWVzc2FnZSk7XHJcbiAgICAgICAgYXdhaXQgb3JpZ2luLmNoZWNrb3V0KFwibWFzdGVyXCIpO1xyXG5cclxuICAgICAgICBjb25zdCBsb2NhbCA9IGF3YWl0IFJlcG9zaXRvcnkuY2xvbmUob3JpZ2luUGF0aCwgbG9jYWxQYXRoKTtcclxuICAgICAgICBhd2FpdCBsb2NhbC5mZXRjaCgpO1xyXG4gICAgICAgIGF3YWl0IGxvY2FsLnJlc2V0SGFyZChcIkhFQUR+MVwiKTtcclxuICAgICAgICBhd2FpdCBsb2NhbC5jaGVja291dChcIi1iXCIsIGZlYXR1cmVCcmFuY2gpO1xyXG5cclxuICAgICAgICBjb25zdCBjdXJyZW50Q29udGVudHMgPSBhd2FpdCBzYW5kYm94LnJlYWRUZXh0RmlsZShcImxvY2FsL3JlYWRtZS5tZFwiKTtcclxuICAgICAgICBleHBlY3QoY3VycmVudENvbnRlbnRzKVxyXG4gICAgICAgICAgICAudG9FcXVhbChyZWFkbWVDb250ZW50cyk7IC8vIHNob3VsZCBoYXZlIHJlYWRtZSByZXNldFxyXG4gICAgICAgIC8vIEFjdFxyXG4gICAgICAgIGF3YWl0IGdpdEJyb2FkY2FzdCh7XHJcbiAgICAgICAgICAgIGluOiBsb2NhbFBhdGgsXHJcbiAgICAgICAgICAgIHRvOiBbIFwiZmVhdHVyZS8qXCIgXVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLy8gQXNzZXJ0XHJcbiAgICAgICAgYXdhaXQgbG9jYWwuY2hlY2tvdXQoZmVhdHVyZUJyYW5jaCk7XHJcbiAgICAgICAgY29uc3QgbG9nID0gYXdhaXQgbG9jYWwubG9nKCk7XHJcbiAgICAgICAgZXhwZWN0KGxvZy5sYXRlc3QubWVzc2FnZSlcclxuICAgICAgICAgICAgLnRvRXF1YWwodXBkYXRlZE1lc3NhZ2UpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoYHNob3VsZCBicm9hZGNhc3QgdG8gYSBnbG9iYmVkIHNpbmdsZSByZWNlaXZlciBmcm9tIHRoZSBzcGVjaWZpZWQgc291cmNlYCwgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIC8vIEFycmFuZ2VcclxuICAgICAgICBjb25zdFxyXG4gICAgICAgICAgICBzYW5kYm94ID0gYXdhaXQgU2FuZGJveC5jcmVhdGUoKSxcclxuICAgICAgICAgICAgZmVhdHVyZUJyYW5jaCA9IFwiZmVhdHVyZS9zdHVmZlwiLFxyXG4gICAgICAgICAgICByZWFkbWVDb250ZW50cyA9IGBpbml0aWFsOiAke2Zha2VyLnJhbmRvbS53b3JkcygpfWAsXHJcbiAgICAgICAgICAgIHVwZGF0ZWRDb250ZW50cyA9IGB1cGRhdGVkOiAke2Zha2VyLnJhbmRvbS53b3JkcygpfWAsXHJcbiAgICAgICAgICAgIGluaXRpYWxNZXNzYWdlID0gXCI6dGFkYTogaW5pdGlhbCBjb21taXRcIixcclxuICAgICAgICAgICAgdXBkYXRlZE1lc3NhZ2UgPSBcIjptZW1vOiBwcmlvciBkb2NzIGFyZSBhbGwgd3JvbmchXCIsXHJcbiAgICAgICAgICAgIG9yaWdpblBhdGggPSBhd2FpdCBzYW5kYm94Lm1rZGlyKFwib3JpZ2luXCIpLFxyXG4gICAgICAgICAgICBsb2NhbFBhdGggPSBhd2FpdCBzYW5kYm94Lm1rZGlyKFwibG9jYWxcIiksXHJcbiAgICAgICAgICAgIG9yaWdpbiA9IFJlcG9zaXRvcnkuY3JlYXRlKG9yaWdpblBhdGgpO1xyXG4gICAgICAgIGF3YWl0IG9yaWdpbi5pbml0KCk7XHJcbiAgICAgICAgYXdhaXQgc2FuZGJveC53cml0ZUZpbGUoXCJvcmlnaW4vcmVhZG1lLm1kXCIsIHJlYWRtZUNvbnRlbnRzKTtcclxuICAgICAgICBhd2FpdCBvcmlnaW4uY29tbWl0QWxsKGluaXRpYWxNZXNzYWdlKTtcclxuICAgICAgICBhd2FpdCBzYW5kYm94LndyaXRlRmlsZShcIm9yaWdpbi9yZWFkbWUubWRcIiwgdXBkYXRlZENvbnRlbnRzKTtcclxuICAgICAgICBhd2FpdCBvcmlnaW4uY29tbWl0QWxsKHVwZGF0ZWRNZXNzYWdlKTtcclxuICAgICAgICBhd2FpdCBvcmlnaW4uY2hlY2tvdXQoXCJtYXN0ZXJcIik7XHJcblxyXG4gICAgICAgIGNvbnN0IGxvY2FsID0gYXdhaXQgUmVwb3NpdG9yeS5jbG9uZShvcmlnaW5QYXRoLCBsb2NhbFBhdGgpO1xyXG4gICAgICAgIGF3YWl0IGxvY2FsLmZldGNoKCk7XHJcbiAgICAgICAgYXdhaXQgbG9jYWwucmVzZXRIYXJkKFwiSEVBRH4xXCIpO1xyXG4gICAgICAgIGF3YWl0IGxvY2FsLmNoZWNrb3V0KFwiLWJcIiwgZmVhdHVyZUJyYW5jaCk7XHJcblxyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRDb250ZW50cyA9IGF3YWl0IHNhbmRib3gucmVhZFRleHRGaWxlKFwibG9jYWwvcmVhZG1lLm1kXCIpO1xyXG4gICAgICAgIGV4cGVjdChjdXJyZW50Q29udGVudHMpXHJcbiAgICAgICAgICAgIC50b0VxdWFsKHJlYWRtZUNvbnRlbnRzKTsgLy8gc2hvdWxkIGhhdmUgcmVhZG1lIHJlc2V0XHJcbiAgICAgICAgLy8gQWN0XHJcbiAgICAgICAgYXdhaXQgZ2l0QnJvYWRjYXN0KHtcclxuICAgICAgICAgICAgaW46IGxvY2FsUGF0aCxcclxuICAgICAgICAgICAgZnJvbTogXCJtYXN0ZXJcIixcclxuICAgICAgICAgICAgdG86IFsgXCJmZWF0dXJlLypcIiBdXHJcbiAgICAgICAgfSlcclxuICAgICAgICAvLyBBc3NlcnRcclxuICAgICAgICBhd2FpdCBsb2NhbC5jaGVja291dChmZWF0dXJlQnJhbmNoKTtcclxuICAgICAgICBjb25zdCBsb2cgPSBhd2FpdCBsb2NhbC5sb2coKTtcclxuICAgICAgICBleHBlY3QobG9nLmxhdGVzdC5tZXNzYWdlKVxyXG4gICAgICAgICAgICAudG9FcXVhbCh1cGRhdGVkTWVzc2FnZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBhZnRlckVhY2goYXN5bmMgKCkgPT4gYXdhaXQgU2FuZGJveC5kZXN0cm95QWxsKCkpO1xyXG59KTtcclxuIl19