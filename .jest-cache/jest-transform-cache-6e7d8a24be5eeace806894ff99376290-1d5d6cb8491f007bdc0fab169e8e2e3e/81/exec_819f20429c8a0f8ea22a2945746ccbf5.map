{"version":3,"file":"C:\\code\\opensource\\git-broadcast\\src\\exec.ts","sources":["C:\\code\\opensource\\git-broadcast\\src\\exec.ts"],"names":[],"mappings":"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","sourcesContent":["import { spawn, SpawnOptions } from \"child_process\";\r\n\r\nexport interface ProcessResult {\r\n    stdout: string[];\r\n    stderr: string[];\r\n    exitCode: number;\r\n    error?: Error;\r\n}\r\n\r\ninterface ExecOptions extends SpawnOptions {\r\n    trimOutputs?: boolean; // when true, trim off empty lines at the end\r\n}\r\n\r\nconst lineTrimRe = /(\\r|\\n|\\r\\n)$/;\r\n\r\n// runs a command and returns the result\r\nexport async function exec(\r\n    cmd: string,\r\n    args: string[],\r\n    options?: ExecOptions\r\n): Promise<ProcessResult> {\r\n    return new Promise((_resolve, _reject) => {\r\n        let completed = false;\r\n        const\r\n            result: ProcessResult = {\r\n                stdout: [],\r\n                stderr: [],\r\n                exitCode: 0,\r\n            },\r\n            isComplete = () => {\r\n                if (completed) {\r\n                    return true;\r\n                }\r\n                completed = true;\r\n                return false;\r\n            },\r\n            trim = options?.trimOutputs === undefined || options?.trimOutputs\r\n                ? trimLines\r\n                : passThrough,\r\n            resolve = (): any => {\r\n                return isComplete() || _resolve(trim(result));\r\n            },\r\n            rejectWith = (err: Error | number) => {\r\n                if (isComplete()) {\r\n                    return;\r\n                }\r\n                if (typeof err === \"number\") {\r\n                    result.exitCode = err;\r\n                } else {\r\n                    result.error = err;\r\n                }\r\n                _reject(trim(result));\r\n            },\r\n            child = spawn(cmd, args, options as SpawnOptions);\r\n        if (!child.stdout) {\r\n            throw new Error(`No stdout acquired for ${ cmd } \"${ args.join(\", \") }\"`);\r\n        }\r\n        child.stdout?.on(\"data\", d => appendLines(result.stdout, d));\r\n        child.stderr?.on(\"data\", d => appendLines(result.stderr, d));\r\n        child.on(\"error\", e => rejectWith(e));\r\n        child.on(\"close\", code => code ? rejectWith(code) : resolve());\r\n    });\r\n}\r\n\r\nfunction trimLines(from: ProcessResult): ProcessResult {\r\n    return {\r\n        ...from,\r\n        stderr: trimEmptyElements(from.stderr),\r\n        stdout: trimEmptyElements(from.stdout)\r\n    }\r\n}\r\n\r\nfunction trimEmptyElements(arr: string[]): string[] {\r\n    let foundData = false;\r\n    return arr.reverse().reduce(\r\n        (acc: string[], cur: string) => {\r\n            if (foundData) {\r\n                acc.push(cur);\r\n            } else if (cur !== \"\") {\r\n                foundData = true;\r\n                acc.push(cur);\r\n            }\r\n            return acc;\r\n        }, [] as string[]\r\n    ).reverse();\r\n}\r\n\r\nfunction passThrough<T>(value: T): T {\r\n    return value;\r\n}\r\n\r\nfunction appendLines(target: string[], data: Buffer) {\r\n    target.push.apply(\r\n        target,\r\n        data.toString()\r\n            .split(\"\\n\")\r\n            .map(l => l.replace(lineTrimRe, \"\"))\r\n    );\r\n}\r\n"]}