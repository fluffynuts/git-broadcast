{"C:\\code\\opensource\\git-broadcast\\tests\\git-broadcast.spec.ts":{"modulePaths":["C:\\code\\opensource\\git-broadcast\\node_modules\\expect-even-more-jest\\dist\\index.d.ts","C:\\code\\opensource\\git-broadcast\\node_modules\\filesystem-sandbox\\dist\\index.d.ts","C:\\code\\opensource\\git-broadcast\\node_modules\\@types\\faker\\index.d.ts","C:\\code\\opensource\\git-broadcast\\src\\git-broadcast.ts","C:\\code\\opensource\\git-broadcast\\tests\\repository.ts"],"testFileContent":"import \"expect-even-more-jest\";\r\nimport { Sandbox } from \"filesystem-sandbox\";\r\nimport * as faker from \"faker\";\r\nimport { gitBroadcast } from \"../src/git-broadcast\";\r\nimport { Repository } from \"./repository\";\r\n\r\ndescribe(`git-broadcast`, () => {\r\n    beforeEach(() => {\r\n        // we're doing fs-ops here, give things a little more\r\n        // time (though they generally won't need it)\r\n        jest.setTimeout(60000);\r\n    });\r\n    it(`should broadcast to a single receiver from the default source`, async () => {\r\n        // Arrange\r\n        const\r\n            sandbox = await Sandbox.create(),\r\n            featureBranch = \"feature/stuff\",\r\n            readmeContents = `initial: ${faker.random.words()}`,\r\n            updatedContents = `updated: ${faker.random.words()}`,\r\n            initialMessage = \":tada: initial commit\",\r\n            updatedMessage = \":memo: prior docs are all wrong!\",\r\n            originPath = await sandbox.mkdir(\"origin\"),\r\n            localPath = await sandbox.mkdir(\"local\"),\r\n            origin = Repository.create(originPath);\r\n        await origin.init();\r\n        await sandbox.writeFile(\"origin/readme.md\", readmeContents);\r\n        await origin.commitAll(initialMessage);\r\n        await sandbox.writeFile(\"origin/readme.md\", updatedContents);\r\n        await origin.commitAll(updatedMessage);\r\n        await origin.checkout(\"master\");\r\n\r\n        const local = await Repository.clone(originPath, localPath);\r\n        await local.fetch();\r\n        await local.resetHard(\"HEAD~1\");\r\n        await local.checkout(\"-b\", featureBranch);\r\n\r\n        const currentContents = await sandbox.readTextFile(\"local/readme.md\");\r\n        expect(currentContents)\r\n            .toEqual(readmeContents); // should have readme reset\r\n        // Act\r\n        await gitBroadcast({\r\n            in: localPath,\r\n            to: [ featureBranch ]\r\n        })\r\n        // Assert\r\n        await local.checkout(featureBranch);\r\n        const log = await local.log();\r\n        expect(log.latest.message)\r\n            .toEqual(updatedMessage);\r\n    });\r\n\r\n    it(`should broadcast to a globbed single receiver from the default source`, async () => {\r\n        // Arrange\r\n        const\r\n            sandbox = await Sandbox.create(),\r\n            featureBranch = \"feature/stuff\",\r\n            readmeContents = `initial: ${faker.random.words()}`,\r\n            updatedContents = `updated: ${faker.random.words()}`,\r\n            initialMessage = \":tada: initial commit\",\r\n            updatedMessage = \":memo: prior docs are all wrong!\",\r\n            originPath = await sandbox.mkdir(\"origin\"),\r\n            localPath = await sandbox.mkdir(\"local\"),\r\n            origin = Repository.create(originPath);\r\n        await origin.init();\r\n        await sandbox.writeFile(\"origin/readme.md\", readmeContents);\r\n        await origin.commitAll(initialMessage);\r\n        await sandbox.writeFile(\"origin/readme.md\", updatedContents);\r\n        await origin.commitAll(updatedMessage);\r\n        await origin.checkout(\"master\");\r\n\r\n        const local = await Repository.clone(originPath, localPath);\r\n        await local.fetch();\r\n        await local.resetHard(\"HEAD~1\");\r\n        await local.checkout(\"-b\", featureBranch);\r\n\r\n        const currentContents = await sandbox.readTextFile(\"local/readme.md\");\r\n        expect(currentContents)\r\n            .toEqual(readmeContents); // should have readme reset\r\n        // Act\r\n        await gitBroadcast({\r\n            in: localPath,\r\n            to: [ \"feature/*\" ]\r\n        })\r\n        // Assert\r\n        await local.checkout(featureBranch);\r\n        const log = await local.log();\r\n        expect(log.latest.message)\r\n            .toEqual(updatedMessage);\r\n    });\r\n\r\n    it(`should broadcast to a globbed single receiver from the specified source`, async () => {\r\n        // Arrange\r\n        const\r\n            sandbox = await Sandbox.create(),\r\n            featureBranch = \"feature/stuff\",\r\n            readmeContents = `initial: ${faker.random.words()}`,\r\n            updatedContents = `updated: ${faker.random.words()}`,\r\n            initialMessage = \":tada: initial commit\",\r\n            updatedMessage = \":memo: prior docs are all wrong!\",\r\n            originPath = await sandbox.mkdir(\"origin\"),\r\n            localPath = await sandbox.mkdir(\"local\"),\r\n            origin = Repository.create(originPath);\r\n        await origin.init();\r\n        await sandbox.writeFile(\"origin/readme.md\", readmeContents);\r\n        await origin.commitAll(initialMessage);\r\n        await sandbox.writeFile(\"origin/readme.md\", updatedContents);\r\n        await origin.commitAll(updatedMessage);\r\n        await origin.checkout(\"master\");\r\n\r\n        const local = await Repository.clone(originPath, localPath);\r\n        await local.fetch();\r\n        await local.resetHard(\"HEAD~1\");\r\n        await local.checkout(\"-b\", featureBranch);\r\n\r\n        const currentContents = await sandbox.readTextFile(\"local/readme.md\");\r\n        expect(currentContents)\r\n            .toEqual(readmeContents); // should have readme reset\r\n        // Act\r\n        await gitBroadcast({\r\n            in: localPath,\r\n            from: \"master\",\r\n            to: [ \"feature/*\" ]\r\n        })\r\n        // Assert\r\n        await local.checkout(featureBranch);\r\n        const log = await local.log();\r\n        expect(log.latest.message)\r\n            .toEqual(updatedMessage);\r\n    });\r\n\r\n    afterEach(async () => await Sandbox.destroyAll());\r\n});\r\n"}}